<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Felix Palmen felix@palmen-it.de">
  <meta name="dcterms.date" content="2017-06-08">
  <title>A beginners' guide away from scanf()</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  * {
      font-family: 'trebuchet ms',arial,sans-serif;
  }
  
  html {
      background-color: #eeeeee;
  }
  
  body {
      width: 90ex;
      position: relative;
      margin-left: -45ex;
      left: 50%;
      padding: 1em;
      background-color: white;
      border: 1px solid #999999;
  }
  
  @media only screen and (max-width: 112ex)
  {
      body
      {
  	width: auto;
  	margin-left: 2px;
  	left: 0;
      }
  }
  
  h2 {
      margin-top: 1.5em;
  }
  
  code, table.sourceCode, pre, code > span {
      background-color: #eeeeee;
      font-family: consolas,courier,monospace;
      font-weight: bold;
  }
  
  table.sourceCode {
      line-height: normal;
      margin: .5em 0;
      padding: 0;
  }
  
  pre code
  {
      padding: .5em;
      display: block;
  }
  
  tr * {
      margin: 0;
      padding: 0;
  }
  
  p {
      margin: .5em 0;
  }
  
  .author, .date
  {
      font-size: 70%;
      color: #999999;
      font-variant: italic;
      margin: 0;
  }
  
  .date
  {
      margin-bottom: 2em;
  }
  
  blockquote {
      background-color: #ffffcc;
      border: 1px solid #999900;
      margin: 1em 0;
      padding: 0 .5em;
  }
  
  </style>
</head>
<body>
<header>
<h1 class="title">A beginners' guide <em>away from</em> <code>scanf()</code></h1>
<p class="author">Felix Palmen <a href="mailto:felix@palmen-it.de">felix@palmen-it.de</a></p>
<p class="date">2017-06-08</p>
</header>
<p>This document is for you if you started to learn programmming in <code>C</code>. Chances are you follow a course and the method to read some input you were taught is to use the <code>scanf()</code> function.</p>
<h2 id="whats-wrong-with-scanf">0. What's wrong with <code>scanf()</code>?</h2>
<p>Nothing. And, chances are, everything for your usecase. This document attempts to make you understand <em>why</em>. So here's the very first rule about <code>scanf()</code>:</p>
<blockquote>
<p><strong>Rule 0:</strong> Don't use <code>scanf()</code>. <span style="font-size: 70%;">(Unless, you know <strong>exactly</strong> what you do.)</span></p>
</blockquote>
<p>But before presenting some alternatives for common usecases, let's elaborate a bit on the <em>knowing what you do</em> part.</p>
<h2 id="i-want-to-read-a-number-from-the-user">1. I want to read a number from the user</h2>
<p>Here is a <em>classic</em> example of <code>scanf()</code> use (and, misuse) in a beginner's program:</p>
<div class="sourceCode" id="example1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">int</span> a;
    printf(<span class="st">&quot;enter a number: &quot;</span>);
    scanf(<span class="st">&quot;%d&quot;</span>, &amp;a);
    printf(<span class="st">&quot;You entered %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, a);
}</code></pre></td></tr></table></div>
<p>As you probably know, <code>%d</code> is the conversion for an integer, so this program works as expected:</p>
<pre><code>$ ./example1
enter a number: 42
You entered 42.</code></pre>
<p>Or does it?</p>
<pre><code>$ ./example1
enter a number: abcdefgh
You entered 38.</code></pre>
<p>Oops. Where does the value <code>38</code> come from?</p>
<p>The answer is: This could be any value, or the program could just crash. A crashing program in just two lines of code is <em>quite easy</em> to create in <code>C</code>. <code>scanf()</code> is asked to convert a number, and the input doesn't contain any numbers, so <code>scanf()</code> converts nothing. As a consequence, the variable <code>a</code> is <em>never written to</em> and using the value of an <em>uninitialized variable</em> in <code>C</code> is <em>undefined behavior</em>.</p>
<blockquote>
<h3 id="undefined-behavior-in-c">Undefined behavior in <code>C</code></h3>
<p>C is a very low-level language and one consequence of that is the following:</p>
<p><em>Nothing will ever stop you from doing something completely wrong</em>.</p>
<p>Many languages, especially those for some <em>managed environment</em> like <code>Java</code> or <code>C#</code> actually stop you when you do things that are not allowed, say, access an array element that does not exist. <code>C</code> doesn't. As long as your program is <em>syntactically</em> correct, the compiler won't complain. If you do something forbidden in your program, <code>C</code> just calls the behavior of your program <strong>undefined</strong>. This formally allows anything to happen when running the program. Often, the result will be a crash or just output of &quot;garbage&quot; values, as seen above. But if you're really unlucky, your program will seem to <em>work just fine</em> until it gets some slightly different input, and by that time, you will have a really hard time to spot where exactly your program is <em>undefined</em>. Therefore <strong>avoid undefined behavior by all means!</strong>.</p>
<p>On a side note, <em>undefined behavior</em> can also cause security holes. This has happened <em>a lot</em> in practice.</p>
</blockquote>
<p>Now that we know the program is broken, let's fix it. Because <code>scanf()</code> returns how many items were converted successfully, the next obvious idea is just to retry the &quot;number input&quot; in case the user entered something else:</p>
<div class="sourceCode" id="example2"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">int</span> a;
    printf(<span class="st">&quot;enter a number: &quot;</span>);
    <span class="cf">while</span> (scanf(<span class="st">&quot;%d&quot;</span>, &amp;a) != <span class="dv">1</span>)
    {
        <span class="co">// input was not a number, ask again:</span>
        printf(<span class="st">&quot;enter a number: &quot;</span>);
    }
    printf(<span class="st">&quot;You entered %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, a);
}</code></pre></td></tr></table></div>
<p>Let's test:</p>
<pre><code>$ ./example2
enter a number: abc
enter a number: enter a number: enter a number: enter a number: enter a
number: enter a number: enter a number: enter a number: enter a number:
enter a number: enter a number: enter a number: enter a number: enter a
number: enter a number: enter a number: enter a number: enter a number:
enter a number: enter a number: enter a number: enter a number: enter a
number: enter a number: enter a number: enter a number: enter a number:
enter a number: enter a number: enter a number: enter a number: enter a
number: enter a number: enter a number: enter a number: enter a number:
enter a number: enter a number: enter a number: enter a number: enter a
number: enter a number: enter a number: enter a number: enter a number:
enter a number: enter a number: enter a number: enter a number: enter a
number: enter a number: enter a number: ^C</code></pre>
<p><strong>stooooop</strong>! Ok, we managed to interrupt this madness with <code>Ctrl+C</code> but <em>why</em> did that happen?</p>
<p>Here's a rule:</p>
<blockquote>
<p><strong>Rule 1:</strong> <code>scanf()</code> is not for <em>reading</em> input, it's for <em>parsing</em> input.</p>
</blockquote>
<p>The first argument to <code>scanf()</code> is a format string, describing what <code>scanf()</code> should parse. The important thing is: <code>scanf()</code> never reads anything it cannot parse. In our example, we tell <code>scanf()</code> to parse a number, using the <code>%d</code> conversion. Sure enough, <code>abc</code> is not a number, and <em>as a consequence, <code>abc</code> is not even read</em>. The next call to <code>scanf()</code> will again find our unread input and, again, can't parse it.</p>
<p>Chances are you find <em>some</em> examples saying &quot;let's just flush the input before the next call to <code>scanf()</code>&quot;:</p>
<pre><code>fflush(stdin); // &lt;- never do that!</code></pre>
<p><strong>Forget about this idea immediately, please.</strong></p>
<p>You'd expect this to clear all unread input, and indeed, some systems will do just that. But <em>according to <code>C</code></em>, flushing an <em>input stream</em> is <strong>undefined behavior</strong>, and this should now ring a bell. And yes, there <em>are</em> a lot of systems that won't clear the input when you attempt to flush <code>stdin</code>.</p>
<p>So, the only way to clear unread input is <em>by reading it</em>. Of course, we can make <code>scanf()</code> read it, using a format string that parses any string. Sounds easy.</p>
<h2 id="i-want-to-read-a-string-from-the-user">2. I want to read a string from the user</h2>
<p>Let's consider another <em>classic</em> example of a beginner's program, trying to read a string from the user:</p>
<div class="sourceCode" id="example3"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">char</span> name[<span class="dv">12</span>];
    printf(<span class="st">&quot;What&#39;s your name? &quot;</span>);
    scanf(<span class="st">&quot;%s&quot;</span>, name);
    printf(<span class="st">&quot;Hello %s!</span><span class="sc">\n</span><span class="st">&quot;</span>, name);
}</code></pre></td></tr></table></div>
<p>As <code>%s</code> is for strings, this should work with any input:</p>
<pre><code>$ ./example3
What&#39;s your name? Paul
Hello Paul!

$ ./example3
What&#39;s your name? Christopher-Joseph-Montgomery
Segmentation fault

$</code></pre>
<p>Well, now we have a <em>buffer overflow</em>. You might get <code>Segmentation fault</code> on a Linux system, any other kind of crash, maybe even a &quot;correctly&quot; working program, because, once again, the program has <strong>undefined behavior</strong>.</p>
<p>The problem here is: <code>%s</code> matches any string, of any length, and <code>scanf()</code> has no idea when to stop reading. It reads as long as it can parse the input according to the format string, so it writes a lot more data to our <code>name</code> variable than the 12 characters we declared for it.</p>
<blockquote>
<h3 id="buffer-overflows-in-c">Buffer overflows in <code>C</code></h3>
<p>A <em>buffer overflow</em> is a specific kind of <em>undefined behavior</em> resulting from a program that tries to write more data to an (array) variable than this variable can hold. Although this is <em>undefined</em>, in practice it will result in overwriting some <em>other</em> data (that happens to be placed after the overflowed buffer in memory) and this can easily crash the program.</p>
<p>One particularly dangerous result of a buffer overflow is overwriting the <em>return address</em> of a function. The return address is used when a function exits, to jump back to the calling function. Being able to overwrite this address ultimately means that a person with enough knowledge about the system can cause the running program to execute <strong>any other code</strong> supplied as input. This problem has led to many security vulnerabilities; imagine you can make for example a webserver written in <code>C</code> execute your own code by submitting a specially tailored request...</p>
</blockquote>
<p>So, here's the next rule:</p>
<blockquote>
<p><strong>Rule 2:</strong> <code>scanf()</code> can be <em>dangerous</em> when used carelessly. Always use field widths with conversions that parse to a string (like <code>%s</code>).</p>
</blockquote>
<p>The field width is a number preceeding the conversion specifier. It causes <code>scanf()</code> to consider a maximum number of characters from the input when parsing for this conversion. Let's demonstrate it in a fixed program:</p>
<div class="sourceCode" id="example4"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">char</span> name[<span class="dv">40</span>];
    printf(<span class="st">&quot;What&#39;s your name? &quot;</span>);
    scanf(<span class="st">&quot;%39s&quot;</span>, name);
    printf(<span class="st">&quot;Hello %s!</span><span class="sc">\n</span><span class="st">&quot;</span>, name);
}</code></pre></td></tr></table></div>
<p>We also increased the buffer size, because there might be really long names.</p>
<p>There's an <strong>important thing to notice</strong>: Although our <code>name</code> has room for 40 characters, we instruct <code>scanf()</code> not to read more than 39. This is because a string in <code>C</code> always needs a <code>0</code> byte appended to mark the end. When <code>scanf()</code> is finished parsing into a string, it appends this byte automatically, and there must be space left for it.</p>
<p>So, this program is now safe from buffer overflows. Let's try something different:</p>
<pre><code>$ ./example4
What&#39;s your name? Martin Brown
Hello Martin!</code></pre>
<p>Well, that's ... outspoken. What happens here? Reading some <code>scanf()</code> manual, we would find that <code>%s</code> parses a <em>word</em>, not a <em>string</em>, for example I found the following wording:</p>
<div style="white-space: pre-line;">    <strong>s</strong>: <em>Matches a sequence of non-white-space characters</em></div>
<p>A <em>white-space</em> in <code>C</code> is one of <em>space</em>, <em>tab</em> (<code>\t</code>) or <em>newline</em> (<code>\n</code>).</p>
<blockquote>
<p><strong>Rule 3:</strong> Although <code>scanf()</code> format strings can look quite similar to <code>printf()</code> format strings, they often have slightly different semantics. <span style="font-size: 70%;">(Make sure to <strong>read the fine manual</strong>)</span></p>
</blockquote>
<p>The general problem with parsing &quot;a string&quot; from an input stream is: <em>Where does this string end?</em> With <code>%s</code>, the answer is <em>at the next white-space</em>. If you want something different, you can use <code>%[</code>:</p>
<ul>
<li><code>%[a-z]</code>: parse as long as the input characters are in the range <code>a</code> - <code>z</code>.</li>
<li><code>%[ny]</code>: parse as long as the input characters are <code>y</code> or <code>n</code>.</li>
<li><code>%[^.]</code>: The <code>^</code> <em>negates</em> the list, so this means parse as long as there is no <code>.</code> in the input.</li>
</ul>
<p>We could change the program, so anything until a <em>newline</em> will be parsed into our string:</p>
<div class="sourceCode" id="example5"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">char</span> name[<span class="dv">40</span>];
    printf(<span class="st">&quot;What&#39;s your name? &quot;</span>);
    scanf(<span class="st">&quot;%39[^</span><span class="sc">\n</span><span class="st">]&quot;</span>, name);
    printf(<span class="st">&quot;Hello %s!</span><span class="sc">\n</span><span class="st">&quot;</span>, name);
}</code></pre></td></tr></table></div>
<p>It might get a bit frustrating, but this is again a program with possible <em>undefined behavior</em>, see what happens when we just press <code>Enter</code>:</p>
<pre><code>$ ./example5
What&#39;s your name? 
Hello ÿ¦e!</code></pre>
<p>Here's another sentence from a <code>scanf()</code> manual, from the section describing the <code>[</code> conversion:</p>
<div style="white-space: pre-line;">    <em>The usual skip of leading white space is suppressed.</em></div>
<p>With many conversions, <code>scanf()</code> automatically skips <em>whitespace</em> characters in the input, but with some, it doesn't. Here, our <em>newline</em> from just pressing enter isn't skipped, and it doesn't match for our conversion that explicitly excludes <em>newlines</em>. The result is: <code>scanf()</code> doesn't parse anything, our <code>name</code> remains <em>uninitialized</em>.</p>
<p>One way around this is to <em>tell</em> <code>scanf()</code> to skip whitespace: If the format string contains any whitespace, it matches any number of whitespace characters in the input, including no whitespace at all. Let's use this to skip whitespace the user might enter before entering his name:</p>
<div class="sourceCode" id="example6"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">char</span> name[<span class="dv">40</span>];
    printf(<span class="st">&quot;What&#39;s your name? &quot;</span>);
    scanf(<span class="st">&quot; %39[^</span><span class="sc">\n</span><span class="st">]&quot;</span>, name);
    <span class="co">//     ^ note the space here, matching any whitespace</span>
    printf(<span class="st">&quot;Hello %s!</span><span class="sc">\n</span><span class="st">&quot;</span>, name);
}</code></pre></td></tr></table></div>
<p>Yes, this program works and doesn't have any <em>undefined behavior</em>*), but I guess you don't like very much that nothing at all happens when you just press enter, because <code>scanf()</code> is skipping it and continues to wait for input that can be matched.</p>
<p><span style="font-size: 70%;">*) actually, this isn't even entirely true. This program <em>still</em> has <em>undefined behavior</em> for empty input. You could force this on a Linux console hitting <code>Ctrl+D</code> for example. So, it's again an example for <em>code you should not write</em>.</span></p>
<h2 id="ok-i-just-want-to-read-some-input-from-the-user">3. Ok, I just want to read <em>some input</em> from the user</h2>
<p>There are several functions in <code>C</code> for <em>reading</em> input. Let's have a look at one that's probably most useful to you: <code>fgets()</code>.</p>
<p><code>fgets()</code> does a simple thing, it reads up to a given maximum number of characters, but stops at a newline, which is read as well. In other words: <em>It reads a line of input.</em></p>
<p>This is the function signature:</p>
<div class="sourceCode" id="snippet1"><pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">char</span> *fgets(<span class="dt">char</span> *str, <span class="dt">int</span> n, FILE *stream)</code></pre></div>
<p>There are two very nice things about this function for what we want to do:</p>
<ul>
<li>The parameter for the maximum length accounts for the necessary <code>0</code> byte, so we can just pass the size of our variable.</li>
<li>The return value is either a pointer to <code>str</code> or <code>NULL</code> if, for any reason, nothing was read.</li>
</ul>
<p>So let's rewrite this program again:</p>
<div class="sourceCode" id="example7"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">char</span> name[<span class="dv">40</span>];
    printf(<span class="st">&quot;What&#39;s your name? &quot;</span>);
    <span class="cf">if</span> (fgets(name, <span class="dv">40</span>, stdin))
    {
        printf(<span class="st">&quot;Hello %s!</span><span class="sc">\n</span><span class="st">&quot;</span>, name);
    }
}</code></pre></td></tr></table></div>
<p>I assure you this is safe, but it has a little flaw:</p>
<pre><code>$ ./example7
What&#39;s your name? Bob
Hello Bob
!</code></pre>
<p>Of course, this is because <code>fgets()</code> also reads the <em>newline</em> character itself. But the fix is simple as well: We use <code>strcspn()</code> to get the index of the <em>newline</em> character if there is one and overwrite it with <code>0</code>. <code>strcspn()</code> is declared in <code>string.h</code>, so we need a new <code>#include</code>:</p>
<div class="sourceCode" id="example8"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;string.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">char</span> name[<span class="dv">40</span>];
    printf(<span class="st">&quot;What&#39;s your name? &quot;</span>);
    <span class="cf">if</span> (fgets(name, <span class="dv">40</span>, stdin))
    {
        name[strcspn(name, <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)] = <span class="dv">0</span>;
        printf(<span class="st">&quot;Hello %s!</span><span class="sc">\n</span><span class="st">&quot;</span>, name);
    }
}</code></pre></td></tr></table></div>
<p>Let's test it:</p>
<pre><code>$ ./example8
What&#39;s your name? Bob Belcher
Hello Bob Belcher!</code></pre>
<h2 id="how-would-i-get-numbers-without-scanf">4. How would I get numbers without <code>scanf()</code>?</h2>
<p>There are many functions for converting a string to a number in <code>C</code>. A function that's used quite often is <code>atoi()</code>, the name means <em>anything to integer</em>. It returns 0 if it can't convert the string. Let's try to rewrite the broken <em>example 2</em> using <code>fgets()</code> and <code>atoi()</code>. <code>atoi()</code> is declared in <code>stdlib.h</code>.</p>
<div class="sourceCode" id="example9"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">int</span> a;
    <span class="dt">char</span> buf[<span class="dv">1024</span>]; <span class="co">// use 1KiB just to be sure</span>

    <span class="cf">do</span>
    {
        printf(<span class="st">&quot;enter a number: &quot;</span>);
        <span class="cf">if</span> (!fgets(buf, <span class="dv">1024</span>, stdin))
        {
            <span class="co">// reading input failed, give up:</span>
            <span class="cf">return</span> <span class="dv">1</span>;
        }

        <span class="co">// have some input, convert it to integer:</span>
        a = atoi(buf);
    } <span class="cf">while</span> (a == <span class="dv">0</span>); <span class="co">// repeat until we got a valid number</span>

    printf(<span class="st">&quot;You entered %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, a);
}</code></pre></td></tr></table></div>
<p>So, trying this out:</p>
<pre><code>$ ./example9
enter a number: foo
enter a number: bar
enter a number: 15x
You entered 15.</code></pre>
<p>Well, not bad so far. But what if we want to allow an actual <code>0</code> to be entered? We can't tell whether <code>atoi()</code> returns <code>0</code> because it cannot convert anything or because there was an actual <code>0</code> in the string. Also, ignoring the extra <code>x</code> when we input <code>15x</code> may not be what we want.</p>
<p><code>atoi()</code> is good enough in many cases, but if you want better error checking, there's an alternative: <code>strtol()</code>:</p>
<div class="sourceCode" id="snippet2"><pre class="sourceCode c"><code class="sourceCode c">    <span class="dt">long</span> <span class="dt">int</span> strtol(<span class="dt">const</span> <span class="dt">char</span> *nptr, <span class="dt">char</span> **endptr, <span class="dt">int</span> base);</code></pre></div>
<p>This looks complicated. But it isn't:</p>
<ul>
<li>endptr is set to point at the first character that couldn't be converted. So you have a way to check whether the whole string was converted.</li>
<li>base allows you to specify any base you expect a number in. Most of the time, this will be <code>10</code>, but you could give <code>16</code> here for parsing hexadecimal or <code>2</code> for parsing binary.</li>
<li><code>strtol()</code> even sets <code>errno</code>, so you can check whether a number was too small or too big for conversion.</li>
</ul>
<p>Now let's use this instead of <code>atoi()</code> (note it returns a <code>long int</code>), making use of every possibility to detect errors:</p>
<div class="sourceCode" id="example10"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">long</span> a;
    <span class="dt">char</span> buf[<span class="dv">1024</span>]; <span class="co">// use 1KiB just to be sure</span>
    <span class="dt">int</span> success; <span class="co">// flag for successful conversion</span>

    <span class="cf">do</span>
    {
        printf(<span class="st">&quot;enter a number: &quot;</span>);
        <span class="cf">if</span> (!fgets(buf, <span class="dv">1024</span>, stdin))
        {
            <span class="co">// reading input failed:</span>
            <span class="cf">return</span> <span class="dv">1</span>;
        }

        <span class="co">// have some input, convert it to integer:</span>
        <span class="dt">char</span> *endptr;

        errno = <span class="dv">0</span>; <span class="co">// reset error number</span>
        a = strtol(buf, &amp;endptr, <span class="dv">10</span>);
        <span class="cf">if</span> (errno == ERANGE)
        {
            printf(<span class="st">&quot;Sorry, this number is too small or too large.</span><span class="sc">\n</span><span class="st">&quot;</span>);
            success = <span class="dv">0</span>;
        }
        <span class="cf">else</span> <span class="cf">if</span> (endptr == buf)
        {
            <span class="co">// no character was read</span>
            success = <span class="dv">0</span>;
        }
        <span class="cf">else</span> <span class="cf">if</span> (*endptr &amp;&amp; *endptr != <span class="ch">&#39;\n&#39;</span>)
        {
            <span class="co">// *endptr is neither end of string nor newline,</span>
            <span class="co">// so we didn&#39;t convert the *whole* input</span>
            success = <span class="dv">0</span>;
        }
        <span class="cf">else</span>
        {
            success = <span class="dv">1</span>;
        }
    } <span class="cf">while</span> (!success); <span class="co">// repeat until we got a valid number</span>

    printf(<span class="st">&quot;You entered %ld.</span><span class="sc">\n</span><span class="st">&quot;</span>, a);
}</code></pre></td></tr></table></div>
<p>And again, let's try:</p>
<pre><code>$ ./example10
enter a number: 565672475687456576574
Sorry, this number is too small or too large.
enter a number: ggggg
enter a number: 15x
enter a number: 0
You entered 0.</code></pre>
<p>This looks really good, doesn't it? If you want to know more, I suggest you read on similar functions like <code>atof()</code>, <code>strtoll()</code>, <code>strtod()</code> etc.</p>
<h2 id="but-can-i-fix-the-examples-with-scanf-as-well">5. But <em>can</em> I fix the examples with <code>scanf()</code> as well?</h2>
<p>Yes, you can. Here's a last rule:</p>
<blockquote>
<p><strong>Rule 4:</strong> <code>scanf()</code> is a <em>very powerful</em> function. <span style="font-size: 70%;">(and with great power comes great responsibility ...)</span></p>
</blockquote>
<p>A lot of parsing work can be done with <code>scanf()</code> in a very <em>concise</em> way, which can be very nice, but it also has many pitfalls and there are tasks (such as reading a line of input) that are much simpler to accomplish with a simpler function. Make sure you <strong>understand the rules</strong> presented here, and if in doubt, read the <code>scanf()</code> manual <strong>precisely</strong>.</p>
<p>That being said, here's an example how to read a number with retries using <code>scanf()</code>:</p>
<div class="sourceCode" id="example11"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">int</span> a;
    <span class="dt">int</span> rc;
    printf(<span class="st">&quot;enter a number: &quot;</span>);
    <span class="cf">while</span> ((rc = scanf(<span class="st">&quot;%d&quot;</span>, &amp;a)) == <span class="dv">0</span>)  <span class="co">// Neither success (1) nor EOF</span>
    {
        <span class="co">// clear what is left, the * means only match and discard:</span>
        scanf(<span class="st">&quot;%*[^</span><span class="sc">\n</span><span class="st">]&quot;</span>);
        <span class="co">// input was not a number, ask again:</span>
        printf(<span class="st">&quot;enter a number: &quot;</span>);
    }
    <span class="cf">if</span> (rc == EOF)
    {
        printf(<span class="st">&quot;Nothing more to read - and no number found</span><span class="sc">\n</span><span class="st">&quot;</span>);
    }
    <span class="cf">else</span>
    {
        printf(<span class="st">&quot;You entered %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, a);
    }
}</code></pre></td></tr></table></div>
<p>It's not as nice as the version using <code>strtol()</code> above, because there is no way to tell <code>scanf()</code> <strong>not</strong> to skip whitespace for <code>%d</code> -- so if you just hit <code>Enter</code>, it will still wait for your input -- but it works and it's a really short program.</p>
<p>For the sake of completeness, if you <em>really</em> <strong><em>really</em></strong> want to get a line of input using <code>scanf()</code>, of course this can be done safely as well:</p>
<div class="sourceCode" id="example12"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    <span class="dt">char</span> name[<span class="dv">40</span>];
    printf(<span class="st">&quot;What&#39;s your name? &quot;</span>);
    <span class="cf">if</span> (scanf(<span class="st">&quot;%39[^</span><span class="sc">\n</span><span class="st">]%*c&quot;</span>, name) == <span class="dv">1</span>) <span class="co">// We expect exactly 1 conversion</span>
    {
        printf(<span class="st">&quot;Hello %s!</span><span class="sc">\n</span><span class="st">&quot;</span>, name);
    }
}</code></pre></td></tr></table></div>
<p>Note that this final example of course leaves input unread, even from the same line, if there were more than 39 characters until the newline. If this is a concern, you'd have to find another way -- or just use <code>fgets()</code>, making the check easier, because it gives you the newline if there was one.</p>
</body>
</html>
